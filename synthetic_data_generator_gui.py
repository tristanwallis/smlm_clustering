# -*- coding: utf-8 -*-
'''
SYNTHETIC_DATA_GENERATOR_GUI 
FREESIMPLEGUI BASED GUI TO GENERATE SYNTHETIC TRXYT FILES USED FOR NANOSCALE SPATIOTEMPORAL INDEXING CLUSTERING (NASTIC AND SEGNASTIC) OR 3D DBSCAN (BOOSH). 

Design and coding: Tristan Wallis and Alex McCann
Queensland Brain Institute
The University of Queensland
Fred Meunier: f.meunier@uq.edu.au

REQUIRED:
Python 3.8 or greater
python -m pip install colorama numpy scipy freesimplegui scikit-learn matplotlib

INPUT (optional):
[1] roi_coordinates.tsv file - ROI file previously generated by NASTIC/segNASTIC/BOOSH
Used in SYNTHETIC to determine the selection area of the synthetic data that is to be generated
If no NASTIC roi_coordinates.tsv file is loaded, the selection area will instead be determined using the x-axis size (um) and y-axis size (um) parameters

Tab separated: ROI# x(um) y(um)
1 header

example:

ROI	x(um)	y(um)
0	4.736320240957679	26.616510133253666
0	4.765490026694448	26.616510133253666
0	4.794659812431218	26.616510133253666
0	4.823829598167988	26.645679918990435
0	4.852999383904757	26.645679918990435
0	4.882169169641527	26.645679918990435
etc

OUTPUT:
[1] .trxyt files - used as input files for NASTIC/segNASTIC/BOOSH
File naming format: synthetic_YYYYMMDD-HHMMSS_file#_.trxyt
Space separated: Trajectory X(um) Y(um) T(sec)  
No headers

example: 

1 9.0117 39.86 0.02
1 8.9603 39.837 0.04
1 9.093 39.958 0.06
1 9.0645 39.975 0.08
2 9.1191 39.932 0.1
2 8.9266 39.915 0.12
etc

[2] metrics.tsv files - contain the parameters that were selected by the user, and the metrics that were generated from these parameters which are then used to generate the .trxyt file. 
No NASTIC ROI file loaded: X-AXIS SIZE (um) and Y-AXIS SIZE (um) parameters are included in the metrics file. 
NASTIC ROI file loaded: the name of the ROI file (ROI FILE) and selection area (ROI AREA) are included in the metrics file. 
File naming format: synthetic_YYYYMMDD-HHMMSS_file#_metrics.tsv

example:

PARAMETERS:
==========
ACQUISITION TIME (s): 320
FRAME TIME (s): 0.02
X-AXIS SIZE (um): 10 	
Y-AXIS SIZE (um): 10
ROI FILE: C:/Documents/PYTHON/20230215_roi_coordinates.tsv
ROI AREA: 726.94
SEED DENSITY (per um2): 2
SEED RADIUS (um): 0.1
MIN TRAJ AROUND SEED: 4
MAX TRAJ AROUND SEED: 12
MIN TRAJ STEPS: 5
MAX TRAJ STEPS: 30
MAX STEPLENGTH (um): 0.1
CLUSTER TRAJ ORBIT: True
NOISE FACTOR: 5
UNCLUST STEPLENGTH MULTIPLIER: 2.0
HOTSPOT PROBABILITY: 0.2
MAX CLUSTERS PER HOTSPOT: 3

GENERATED METRICS:
=================
TOTAL TRAJECTORIES: 1895
CLUSTERED TRAJECTORIES: 895
UNCLUSTERED TRAJECTORIES: 1000
TOTAL CLUSTERS: 110
SINGLETON CLUSTERS: 80
AVERAGE TRAJECTORIES PER CLUSTER: 8.136363636363637 +/- 0.2358306132306391
AVERAGE CLUSTER RADIUS: 0.08004795415240253 +/- 0.0009018811959358476

Generated .trxyt files [1] and corresponding metrics.tsv files [2] are saved within the same directory as the  synthetic_data_generator_gui.py script, in a folder that is created with the naming format: synthetic_data_output_YYYYMMDD-HHMMSS

NOTES: 
This script has been tested and will run as intended on Windows 7/10/11, with minor interface anomalies on Linux, and possible tk GUI performance issues on MacOS.
Feedback, suggestions and improvements are welcome. Sanctimonious critiques on the pythonic inelegance of the coding are not.

CHECK FOR UPDATES:
https://github.com/tristanwallis/smlm_clustering/releases
'''

last_changed = "20250701"

# MAIN PROG AND FUNCTIONS
if __name__ == "__main__":
	# LOAD MODULES
	print ("\nLoading modules...")
	import FreeSimpleGUI as sg
	import os
	from colorama import init as colorama_init
	from colorama import Fore
	from colorama import Style

	sg.set_options(dpi_awareness=True) # turns on DPI awareness (Windows only)
	sg.theme('DARKGREY11')
	colorama_init()
	os.system('cls' if os.name == 'nt' else 'clear')
	
	print(f'{Fore.GREEN}============================================================{Style.RESET_ALL}')
	print(f'{Fore.GREEN}SYNTHETIC {last_changed} initialising...{Style.RESET_ALL}')
	print(f'{Fore.GREEN}============================================================{Style.RESET_ALL}')

	# POPUP WINDOW
	popup = sg.Window("Initialising...",[[sg.T("SYNTHETIC DATA GENERATOR initialising\nLots of modules...",font=("Arial bold",18))]],finalize=True,no_titlebar = True,alpha_channel=0.9)
	
	import random
	from scipy.spatial import ConvexHull
	from sklearn.cluster import DBSCAN
	import numpy as np
	import matplotlib
	matplotlib.use('TkAgg') # prevents Matplotlib related crashes --> self.tk.call('image', 'delete', self.name)
	import matplotlib.pyplot as plt
	from matplotlib import path
	import math
	import time	
	import datetime
	import pickle
	import io
	import webbrowser
	import warnings
	warnings.filterwarnings("ignore")
	
	# SIMPLE CONVEX HULL AROUND SPLASH CLUSTERS
	def hull(points):
		points = np.array(points)
		hull = ConvexHull(points)
		hullarea = hull.volume
		vertices = hull.vertices
		vertices = np.append(vertices,vertices[0])
		hullpoints = np.array(points[hull.vertices])
		return hullpoints,hullarea
		
	# DBSCAN
	def dbscan(points,epsilon,minpts):
		db = DBSCAN(eps=epsilon, min_samples=minpts).fit(points)
		core_samples_mask = np.zeros_like(db.labels_, dtype=bool)
		core_samples_mask[db.core_sample_indices_] = True
		labels = db.labels_ # which sample belongs to which cluster
		clusterlist = list(set(labels)) # list of clusters
		return labels,clusterlist
			
	# CREATE AND DISPLAY EACH SPLASH MOLECULE
	def initialise_particles(graph):
		colors = ["#0f0","#010"]
		particles=100
		particle_size=1
		xmin =-180
		xmax=180
		ymin=-100
		ymax=100
		obj_list = []
		fill,line=colors
		for i in range(particles):
			startpos = [random.randint(xmin,xmax),random.randint(ymin,ymax)]
			obj = graph.draw_circle(startpos,particle_size,fill_color=fill,line_color=line,line_width=0)
			xm = random.uniform(-1, 1)
			ym = random.uniform(-1, 1)
			obj_list.append([obj,startpos,xm,ym])
		return obj_list	
		
	# CREATE ANIMATED SPLASH
	def create_splash():
		stepsize=4
		slowdown = 15
		xmin =-300
		xmax=300
		ymin=-170
		ymax=170
		epsilon=10
		minpts=3
		timeout=50
		clusters = []
		cluster_update = 250 
		cluster_color = "#900"
		canvas="#000"
		ct = 0
		sg.theme('DARKGREY11')
		graph = sg.Graph((xmax-xmin,ymax-ymin),graph_bottom_left = (xmin,ymin),graph_top_right = (xmax,ymax),background_color=canvas,key="-GRAPH-",pad=(0,0))
		layout = [
			[graph],
			[sg.Button("OK",key="-OK-")]
		]
		splash = sg.Window("Cluster Sim",layout, no_titlebar = True,finalize=True,alpha_channel=0.9,grab_anywhere=True,element_justification="c", keep_on_top = True)
		obj_list=initialise_particles(graph)
		graph.DrawText("S Y N T H E T I C v{}".format(last_changed),(0,130),color="white",font=("Any",16),text_location="center")
		graph.DrawText("Design and coding: Tristan Wallis and Alex McCann",(0,50),color="white",font=("Any",10),text_location="center")
		graph.DrawText("Queensland Brain Institute",(0,-20),color="white",font=("Any",10),text_location="center")	
		graph.DrawText("The University of Queensland",(0,-50),color="white",font=("Any",10),text_location="center")	
		graph.DrawText("Fred Meunier f.meunier@uq.edu.au",(0,-80),color="white",font=("Any",10),text_location="center")	
		graph.DrawText("FreeSimpleGUI: https://pypi.org/project/FreeSimpleGUI/",(0,-120),color="white",font=("Any",10),text_location="center")	
		while True:	
			# READ AND UPDATE VALUES
			event, values = splash.read(timeout=timeout) 
			ct += timeout
			# Exit	
			if event in (sg.WIN_CLOSED, '-OK-'): 
				break
			# UPDATE EACH PARTICLE
			# Dbscan to check for interacting points
			allpoints = [i[1] for i in obj_list]
			labels,clusterlist = dbscan(allpoints,epsilon,minpts)
			# Alter particle movement		
			for num,obj in enumerate(obj_list):
				dot,pos,xm,ym = obj 
				splash["-GRAPH-"].move_figure(dot,xm,ym)
				pos[0]+=xm
				pos[1]+=ym
				# Closed universe
				if pos[0] > xmax:
					pos[0] = xmin
					splash["-GRAPH-"].RelocateFigure(dot,pos[0],pos[1])
				if pos[0] < xmin:
					pos[0] = xmax
					splash["-GRAPH-"].RelocateFigure(dot,pos[0],pos[1])			
				if pos[1] > ymax:
					pos[1] = ymin
					splash["-GRAPH-"].RelocateFigure(dot,pos[0],pos[1])	
				if pos[1] < ymin:
					pos[1] = ymax	
					splash["-GRAPH-"].RelocateFigure(dot,pos[0],pos[1])	
				# Lower speed in a cluster		
				if labels[num] > -1:
					obj[2] = random.uniform(-(slowdown/100)*stepsize, (slowdown/100)*stepsize)
					obj[3] = random.uniform(-(slowdown/100)*stepsize, (slowdown/100)*stepsize)
				# Randomly change direction and speed
				else:	
					obj[2] = random.uniform(-stepsize, stepsize)
					obj[3] = random.uniform(-stepsize, stepsize)
			# Draw borders around clusters
			if ct > cluster_update:
				ct = 0
				if len(clusters) > 0:
					for cluster in clusters:
						splash["-GRAPH-"].delete_figure(cluster)
					clusters = []
				allpoints = [i[1] for i in obj_list]
				labels,clusterlist = dbscan(allpoints,epsilon*1.5,minpts)	
				clusterdict = {i:[] for i in clusterlist}	
				for num,obj in enumerate(obj_list):
					clusterdict[labels[num]].append(obj[1])
				for clust in clusterdict:
					if clust > -1:
						clusterpoints = clusterdict[clust]
						try:
							hullpoints,hullarea = hull(clusterpoints)
							cluster = splash["-GRAPH-"].draw_polygon(hullpoints,line_width=2,line_color=cluster_color,fill_color=canvas)
							splash["-GRAPH-"].send_figure_to_back(cluster)
							clusters.append(cluster)
						except:
							pass
		return splash
	
	# USE HARD CODED DEFAULTS
	def reset_defaults():
		print ("\nUsing default GUI settings...")
		global acquisition_time, frame_time, use_xy, use_ROI, x_size, y_size, seed_density, radius, min_traj_num, max_traj_num, orbit, min_traj_length, max_traj_length, steplength, noise_factor, unconst, hotspotprobability, hotspotmax, display_all_plots, save_all_plots, trxyt_num 
		acquisition_time = 320 
		frame_time = 0.02
		use_xy = True # define the selection area using pretend x,y frame size
		use_ROI = False # define the selection area using presaved NASTIC ROI file
		x_size = 10
		y_size = 10
		seed_density = 2
		radius = 0.1
		min_traj_num = 4
		max_traj_num = 12
		orbit = True
		min_traj_length = 5
		max_traj_length = 30
		steplength = 0.1
		noise_factor = 5
		unconst = 2.0
		hotspotprobability = 0.2
		hotspotmax = 3
		display_all_plots = False
		save_all_plots = False
		trxyt_num = 1 # number of trxyt files to generate
		return 
	
	# SAVE SETTINGS
	def save_defaults():
		print ("\nSaving GUI settings to synthetic_data_generator_gui.defaults...")
		with open("synthetic_data_generator_gui.defaults","w") as outfile:
			outfile.write("{}\t{}\n".format("Acquisition time (s)",acquisition_time))
			outfile.write("{}\t{}\n".format("Frame time (s)",frame_time))
			outfile.write("{}\t{}\n".format("Use ROI",use_ROI))
			outfile.write("{}\t{}\n".format("x-axis size (um)",x_size))
			outfile.write("{}\t{}\n".format("y-axis size (um)",y_size))
			outfile.write("{}\t{}\n".format("Seed density (#/um)",seed_density))
			outfile.write("{}\t{}\n".format("Seed radius (um)",radius))
			outfile.write("{}\t{}\n".format("Minimum trajectory number",min_traj_num))
			outfile.write("{}\t{}\n".format("Maximum trajectory number",max_traj_num))
			outfile.write("{}\t{}\n".format("Minimum trajectory length",min_traj_length))
			outfile.write("{}\t{}\n".format("Maximum trajectory length",max_traj_length))
			outfile.write("{}\t{}\n".format("Clustered step length (um)",steplength))
			outfile.write("{}\t{}\n".format("Trajectories orbit seed",orbit))
			outfile.write("{}\t{}\n".format("Noise factor",noise_factor))
			outfile.write("{}\t{}\n".format("Step length multiplier",unconst))
			outfile.write("{}\t{}\n".format("Hotspot probability",hotspotprobability))
			outfile.write("{}\t{}\n".format("Maximum hotspot trajectory number",hotspotmax))
			outfile.write("{}\t{}\n".format("Display all plots",display_all_plots))
			outfile.write("{}\t{}\n".format("Save displayed plots",save_all_plots))
			outfile.write("{}\t{}\n".format("Number of trxyt files to generate",trxyt_num))
		return
	
	# LOAD DEFAULTS
	def load_defaults():
		global acquisition_time, frame_time, use_ROI, use_xy, x_size, y_size, seed_density, radius, min_traj_num, max_traj_num, orbit, min_traj_length, max_traj_length, steplength, noise_factor, unconst, hotspotprobability, hotspotmax, display_all_plots, save_all_plots, trxyt_num
		try:
			with open ("synthetic_data_generator_gui.defaults","r") as infile:
				print ("\nLoading GUI settings from synthetic_data_generator_gui.defaults...")
				defaultdict = {}
				for line in infile:
					spl = line.split("\t")
					defaultdict[spl[0]] = spl[1].strip()
			acquisition_time = int(defaultdict["Acquisition time (s)"])
			frame_time = float(defaultdict["Frame time (s)"])
			use_ROI = defaultdict["Use ROI"]
			if use_ROI == "True":
				use_ROI = True
				use_xy = False
			else:
				use_ROI = False
				use_xy = True
			x_size = int(defaultdict["x-axis size (um)"])
			y_size = int(defaultdict["y-axis size (um)"])
			seed_density = int(defaultdict["Seed density (#/um)"])
			radius = float(defaultdict["Seed radius (um)"])
			min_traj_num = int(defaultdict["Minimum trajectory number"])
			max_traj_num = int(defaultdict["Maximum trajectory number"])
			orbit = defaultdict["Trajectories orbit seed"]
			if orbit == "True":
				orbit = True
			else:
				orbit = False
			min_traj_length = int(defaultdict["Minimum trajectory length"])
			max_traj_length = int(defaultdict["Maximum trajectory length"])
			steplength = float(defaultdict["Clustered step length (um)"])
			noise_factor = int(defaultdict["Noise factor"])
			unconst = float(defaultdict["Step length multiplier"])
			hotspotprobability = float(defaultdict["Hotspot probability"])
			hotspotmax = int(defaultdict["Maximum hotspot trajectory number"])
			display_all_plots = defaultdict["Display all plots"]
			if display_all_plots == "True":
				display_all_plots = True
			else:
				display_all_plots = False
			save_all_plots = defaultdict["Save displayed plots"]
			if save_all_plots == "True":
				save_all_plots = True
			else:
				save_all_plots = False
			trxyt_num = int(defaultdict["Number of trxyt files to generate"])
		except:
			print ("\nSettings could not be loaded")
		return
		
	# UPDATE GUI BUTTONS
	def update_buttons():
		window.Element("-ACQ_TIME-").update(acquisition_time)
		window.Element("-FRAME_TIME-").update(frame_time)
		window.Element("-USE_XY-").update(use_xy)
		window.Element("-USE_ROI-").update(use_ROI)
		window.Element("-SEED_DENSITY-").update(seed_density)
		window.Element("-MIN_TRAJ_NUM-").update(min_traj_num)
		window.Element("-MAX_TRAJ_NUM-").update(max_traj_num)
		window.Element("-MIN_TRAJ_LEN-").update(min_traj_length)
		window.Element("-MAX_TRAJ_LEN-").update(max_traj_length)
		window.Element("-X_SIZE-").update(x_size)
		window.Element("-Y_SIZE-").update(y_size)
		window.Element("-RADIUS-").update(radius)
		window.Element("-STEP_LEN-").update(steplength)
		window.Element("-NOISE_FACTOR-").update(noise_factor)
		window.Element("-STEP_LEN_UNCLUST-").update(unconst)
		window.Element("-HOTSPOT_PROB-").update(hotspotprobability)
		window.Element("-MAX_HOTSPOT_TRAJ-").update(hotspotmax)
		window.Element("-ORBIT-").update(orbit)
		window.Element("-DISPLAY_ALL_PLOTS-").update(display_all_plots)
		window.Element("-SAVE_ALL_PLOTS-").update(save_all_plots)
		window.Element("-TRXYT_NUM-").update(trxyt_num)
		return
	
	# CHECK VARIABLES
	def check_variables():
		global acquisition_time, frame_time, seed_density, min_traj_num, max_traj_num, min_traj_length, max_traj_length, x_size, y_size, radius, steplength, noise_factor, unconst, hotspotprobability, hotspotmax, orbit, trxyt_num
		
		try:
			acquisition_time = int(acquisition_time)
			if acquisition_time < 1:
				acquisition_time = 1
		except:
			acquisition_time = 320
		
		try:
			frame_time = float(frame_time)
			if frame_time <= 0:
				frame_time = 0.02
		except:
			frame_time = 0.02
		
		try: 
			seed_density = int(seed_density)
			if seed_density < 1:
				seed_density = 2
		except:
			seed_density = 2
		
		try: 
			min_traj_num = int(min_traj_num)
			if min_traj_num < 4:
				min_traj_num = 4
		except:
			min_traj_num = 4
		
		try:
			max_traj_num = int(max_traj_num)
			if max_traj_num <= min_traj_num:
				max_traj_num = min_traj_num + 1
			if max_traj_num > 10000:
				max_traj_num = 10000
		except:
			max_traj_num = 12
			
		try:
			min_traj_length = int(min_traj_length)
			if min_traj_length < 5:
				min_traj_length = 5 
		except:
			min_traj_length = 5
			
		try:
			max_traj_length = int(max_traj_length)
		except:
			max_traj_length = 30
			
		if max_traj_length < min_traj_length:
			min_traj_length = 5
			max_traj_length = 30
			
		try:
			x_size = int(x_size)
			if x_size < 1:
				x_size = 10
		except:
			x_size = 10
			
		try:
			y_size = int(y_size)
			if y_size < 1:
				y_size = 10
		except:
			y_size = 10
			
		try:
			radius = float(radius)
			if radius <= 0:
				radius = 0.1
		except:
			radius = 0.1
			
		try: 
			steplength = float(steplength)
			if steplength <= 0:
				steplength = 0.1
		except:
			steplength = 0.1
			
		try:
			noise_factor = int(noise_factor)
			if noise_factor < 0:
				noise_factor = 1
		except:
			noise_factor = 5
		
		try:
			unconst = float(unconst)
			if unconst < 1.0:
				unconst = 1.0
		except:
			unconst = 2.0
			
		try:
			hotspotprobability = float(hotspotprobability)
			if hotspotprobability <= 0:
				hotspotprobability = 0.2
		except:
			hotspotprobability = 0.2
			
		try:
			hotspotmax = int(hotspotmax)
			if hotspotmax < 2:
				hotspotmax = 2
		except:
			hotspotmax = 3
		
		try:
			trxyt_num = int(trxyt_num)
			if trxyt_num <= 0:
				trxyt_num = 1
		except:
			trxyt_num = 1
			
		return
		
	# VALS
	clusterdict = {} # dictionary holding clusters
	
	# FUNCTIONS
	
	# CONVEX HULL OF EXTERNAL POINTS, AND THEN INTERNAL POINTS
	def double_hull(points):
		# Get the hull of the original points
		all_points = np.array(points)
		ext_hull = ConvexHull(all_points)
		ext_area = ext_hull.volume
		vertices = ext_hull.vertices
		vertices = np.append(vertices,vertices[0])
		ext_x = [all_points[vertex][0] for vertex in vertices]
		ext_y = [all_points[vertex][1] for vertex in vertices]
		ext_points = np.array(all_points[ext_hull.vertices])
			
		# Get the hull of the points inside the hull
		int_points = np.array([x for x in all_points if x not in ext_points])
		try:
			int_hull = ConvexHull(int_points)
			int_area = int_hull.volume
			vertices = int_hull.vertices
			vertices = np.append(vertices,vertices[0])
			int_x = [int_points[vertex][0] for vertex in vertices]
			int_y = [int_points[vertex][1] for vertex in vertices]
		except:
			int_x,int_y,int_area = ext_x,ext_y,ext_area
		return ext_x,ext_y,ext_area,int_x,int_y,int_area

	# ROI AREA	
	def PolyArea(x,y):
		return 0.5*np.abs(np.dot(x,np.roll(y,1))-np.dot(y,np.roll(x,1)))	

	# OBTAIN POINTS BETWEEN TWO TRAJECTORY COORDINATES
	def obtain_midpoints(trajx_before,trajy_before,x,y):
		midpoint_x_list = []
		midpoint_y_list = []
		midpoint_x = (x-trajx_before)/7
		midpoint_y = (y-trajy_before)/7
		for i in range(1,7):
			point_x = trajx_before + (i*midpoint_x)
			midpoint_x_list.append(point_x)
			point_y = trajy_before + (i*midpoint_y)
			midpoint_y_list.append(point_y)
		midpoint_list = zip(midpoint_x_list,midpoint_y_list)
		return(midpoint_list)
		
	# READ ROI FILE	
	def read_roi():
		global allx, ally, selverts,roidict,p_list,selarea_list
		print ("\nLoading NASTIC ROI file")
		print("------------------------------------------------------------")
		print("NASTIC ROI file selected: \n{}".format(roi_file))
		print("Reading ROI file...")
		roidict = {}
		allx = []
		ally = []
		with open (roi_file,"r") as infile:
			for line in infile:
				spl = line.split("\t")
				try:
					roi = int(spl[0])
					x = float(spl[1])
					y = float(spl[2])
					if x < 0:
						x = 0.0 # prevent crash if roi file contains negative x values
					if y < 0:
						y = 0.0 # prevent crash if roi file contains negative y values
					allx.append(x)
					ally.append(y)
					try:
						roidict[roi].append([x,y])
					except:	
						roidict[roi] = []
						roidict[roi].append([x,y])
				except:
					pass
		p_list = [] # list of ROI paths (1 per ROI in ROI file)
		selarea_list = [] # list of ROI selection areas (1 per ROI in ROI file)
		roi_ct = 0
		for roi in roidict:
			roi_ct+=1
			selverts =roidict[roi]
			p = path.Path(selverts)
			p_list.append(p)
			selarea =PolyArea(list(zip(*selverts))[0],list(zip(*selverts))[1])
			selarea_list.append(selarea)
		print("{} ROIs found in ROI file".format(roi_ct))
		return()
	
	# GENERATE TRXYT
	def generate_trxyt(Load_ROI):
		global trajectories, clusttrajcounter, clustercounter, traj_nums, radii, seed_num, noise,selverts,roidict,x_size, y_size,trajectory_list,clusttrajcounter_list, noise_list,clustercounter_list,traj_nums_list,seed_num_list,radii_list,frame_time_round_val
		
		# SEEDS
		seeds = []
		
		# ROUND TIME BY FRAME TIME
		frame_time_split = str(frame_time).split(".")
		frame_time_decimal = frame_time_split[-1]
		if int(frame_time_decimal) == 0:
			frame_time_round_val = 0
		else:
			frame_time_round_val = len(frame_time_decimal)
				
		# Using NASTIC ROI to define selection area
		if Load_ROI == True:
			# Multiple ROIs in ROI file
			if len(roidict) > 1:
				print("\nGenerating trajectories (ROI #{})".format(roi))
				print("------------------------------------------------------------")
			print("Selection area: ", selarea)
			seed_num=int(seed_density*(round(selarea,0)))
			if seed_num == 0:
				seed_num = 1 # prevent crash if seed number is zero
			noise = seed_num * noise_factor
			print ("Generating {} spatiotemporal cluster seeds ({} seeds/um2)...".format(seed_num, seed_density))
			xmin = min(allx)
			xmax = max(allx)
			ymin = min(ally)
			ymax = max(ally)
			ct = 0
			while ct < seed_num:
				x = random.uniform(xmin,xmax) # random x
				y = random.uniform(ymin,ymax) # random y
				t = random.random()*acquisition_time # random t
				
				# test whether t can be divided by frame time -> adjust value if not
				int_t = int(round(t*10**frame_time_round_val,0))
				int_frame_time = int(round(frame_time*10**frame_time_round_val,0))
				while int_t %int_frame_time !=0:
					int_t += 1
				t = round(int_t*10**-frame_time_round_val,frame_time_round_val)
				
				if p.contains_point([x,y]):
					seeds.append([x,y,t])
					ct +=1
		
		# Using x_size and y_size to define selection area
		elif Load_ROI == False:
			seed_num = seed_density*(round(x_size*y_size,0))
			noise = seed_num * noise_factor
			print ("Generating {} spatiotemporal cluster seeds ({} seeds/um2)...".format(seed_num, seed_density))
			ct = 0
			while ct < seed_num:
				x = random.random()*x_size # random x
				y = random.random()*y_size # random y
				t = round(random.random()*acquisition_time,frame_time_round_val) # random t
				
				# test whether t can be divided by frame time -> adjust value if not
				int_t = int(round(t*10**frame_time_round_val,0))
				int_frame_time = int(round(frame_time*10**frame_time_round_val,0))
				while int_t %int_frame_time !=0:
					int_t += 1
				t = round(int_t*10**-frame_time_round_val,frame_time_round_val)
				
				seeds.append([x,y,t])
				ct +=1
	
		# TRAJECTORIES
		print ("Generating trajectories around cluster seeds...")
		clustercounter = 0
		clusttrajcounter = 0
		trajectories = []
		if Load_ROI == True:
			roi_ct = 0
			for rois in roidict:
				roi_ct +=1
			if roi == 0 or roi_ct == 1:
				# lists contain metrics for each ROI found in ROI file
				trajectory_list = [] # trajectories
				clusttrajcounter_list = [] # number of clustered trajectories
				noise_list = [] # number of unclustered trajectories
				clustercounter_list = [] # number of clusters
				traj_nums_list = [] # number of trajectories per cluster
				seed_num_list = [] # number of singleton clusters
				radii_list = [] # cluster radii 
		for seed in seeds:
			# Original cluster at each seed point
			clustercounter+=1
			x_seed,y_seed,t_seed = seed[0],seed[1],seed[2] # x, y and t for this cluster
			trajnum = random.randint(min_traj_num,max_traj_num) # number of trajectories for this cluster
			clusterdict[clustercounter]={"trajectories":[]} # empty trajectory dictionary for this cluster
			for j in range(trajnum):
				x_orig = x_seed + 0.5*(random.uniform(-radius,radius)) # starting x point for trajectory 
				y_orig = y_seed + 0.5*(random.uniform(-radius,radius))# starting y point for trajectory
				t = round((t_seed + (random.random()*10))/2,frame_time_round_val)*2 # starting time, within 10 sec of the cluster t 
				
				# test whether t can be divided by frame time -> adjust value if not
				int_t = int(round(t*10**frame_time_round_val,0))
				int_frame_time = int(round(frame_time*10**frame_time_round_val,0))
				while int_t %int_frame_time !=0:
					int_t += 1
				t = round(int_t*10**-frame_time_round_val,frame_time_round_val)

				traj_length = random.randint(min_traj_length,max_traj_length) # steps for this trajectory
				x = x_orig
				y = y_orig
				
				# Using NASTIC ROI to define selection area
				if Load_ROI == True:
					traj = []
					ct = 0
					try_ct = 1
					point_ct = 0
					while ct < traj_length:
						if try_ct == 1000:
							x_orig = x_seed + 0.5*(random.uniform(-radius,radius)) # starting x point for trajectory 
							y_orig = y_seed + 0.5*(random.uniform(-radius,radius))# starting y point for trajectory
							x = x_orig
							y = y_orig
							traj = []
							ct = 0
							try_ct = 1
							point_ct = 0
						# Orbit
						if orbit:
							# Random walk constrained around spawn point
							angle = random.uniform(0,360) # random angle for trajectory step
							distance = random.uniform(-steplength,steplength) # random steplength for trajectory step
							x = x_orig +math.sin(angle)*distance 
							y = y_orig + math.cos(angle)*distance 
							if p.contains_point([x,y]):	
								if ct > 0:	
									trajx_before = traj[ct-1][0]
									trajy_before = traj[ct-1][1]
									midpoint_list = obtain_midpoints(trajx_before,trajy_before,x,y)
									midpointlistct = 0
									for x_midpoint,y_midpoint in midpoint_list:
										midpointlistct += 1
										if p.contains_point([x_midpoint,y_midpoint]):
											point_ct +=1
									if point_ct == 6:
										t += frame_time
										t = round(t,frame_time_round_val)
										traj.append([x,y,t])
										ct += 1
										try_ct = 1
										point_ct = 0
									else:
										point_ct = 0
										try_ct += 1
								else:
									t = seed[2]
									traj.append([x,y,t])
									ct += 1
							else:
								try_ct +=1
						
						# No orbit
						else:	
							# Random walk unconstrained, can wander from spawn point
							prevx = x
							prevy = y
							angle = random.uniform(0,360) # random angle for trajectory step
							distance = random.uniform(-steplength,steplength) # random steplength for trajectory step
							x += math.sin(angle)*distance 
							y = y + math.cos(angle)*distance
							if p.contains_point([x,y]):	
								if ct > 0:	
									trajx_before = traj[ct-1][0]
									trajy_before = traj[ct-1][1]
									midpoint_list = obtain_midpoints(trajx_before,trajy_before,x,y)
									midpointlistct = 0
									for x_midpoint,y_midpoint in midpoint_list:
										midpointlistct += 1
										if p.contains_point([x_midpoint,y_midpoint]):
											point_ct +=1
									if point_ct == 6:
										t += frame_time
										t = round(t, frame_time_round_val)
										traj.append([x,y,t])
										ct += 1
										try_ct = 1
										point_ct = 0
									else:
										point_ct = 0
										try_ct += 1
										x = prevx
										y = prevy
								else:
									t = seed[2]
									traj.append([x,y,t])
									ct += 1
							else:
								try_ct +=1
								x = prevx
								y = prevy 
									
					trajectories.append(traj)
					clusttrajcounter +=1
					clusterdict[clustercounter]["trajectories"].append(traj)
				
				# Using x_size and y_size to define selection area
				elif Load_ROI == False:
					traj = []
					ct = 0
					try_ct = 1
					while ct < traj_length:
						if try_ct == 1000:
							traj = []
							x_orig = x_seed + 0.5*(random.uniform(-radius,radius))
							y_orig = y_seed + 0.5*(random.uniform(-radius,radius))
							x = x_orig 
							y = y_orig 
							ct = 0
							try_ct = 1
						
						# Orbit
						if orbit:	
							# Random walk constrained around spawn point
							angle = random.uniform(0,360) # random angle for trajectory step
							distance = random.uniform(-steplength,steplength) # random steplength for trajectory step
							x = x_orig +math.sin(angle)*distance
							if x > x_size:
								x = x_size
							if x<0:
								x = 0
							y = y_orig + math.cos(angle)*distance	
							if y>y_size:
								y=y_size
							if y<0:
								y=0
							if x < x_size and x > 0 and y < y_size and y > 0:
								t += frame_time
								t = round(t,frame_time_round_val)
								traj.append([x,y,t])
								ct += 1
								try_ct = 1
							else:
								try_ct += 1	
						
						# No orbit
						else:	
							# Random walk unconstrained, can wander from spawn point
							prevx = x
							prevy = y
							angle = random.uniform(0,360) # random angle for trajectory step
							distance = random.uniform(-steplength,steplength) # random steplength for trajectory step
							x = x +math.sin(angle)*distance
							if x > x_size:
								x = x_size
							if x<0:
								x = 0
							y = y + math.cos(angle)*distance	
							if y>y_size:
								y=y_size
							if y<0:
								y=0		
							if x < x_size and x > 0 and y < y_size and y > 0:
								t += frame_time
								t = round(t,frame_time_round_val)
								traj.append([x,y,t])
								ct += 1
								try_ct = 1
							else:
								try_ct += 1	
								x = prevx
								y = prevy
								
					trajectories.append(traj)
					clusttrajcounter +=1
					clusterdict[clustercounter]["trajectories"].append(traj)
			
			# Spatially overlapping, temporally distinct clusters at each seed point 	
			if random.random() < hotspotprobability:
				for k in range(0,random.randint(1,hotspotmax-1)):
					clustercounter+=1
					clusterdict[clustercounter]={"trajectories":[]}
					x_seed = seed[0]+ random.uniform(-0.25,0.25)*radius # hotspot cluster x
					y_seed = seed[1]+ random.uniform(-0.25,0.25)*radius # hotspot cluster y
					t_seed = random.random()*acquisition_time
					trajnum = random.randint(min_traj_num,max_traj_num)
					for tr in range(trajnum):
						x_orig = x_seed + 0.5*(random.uniform(-radius,radius))
						y_orig = y_seed + 0.5*(random.uniform(-radius,radius))
						t = round((t_seed + (random.random()*10))/2,frame_time_round_val)*2
						
						# test whether t can be divided by frame time -> adjust value if not
						int_t = int(round(t*10**frame_time_round_val,0))
						int_frame_time = int(round(frame_time*10**frame_time_round_val,0))
						while int_t %int_frame_time !=0:
							int_t += 1
						t = round(int_t*10**-frame_time_round_val,frame_time_round_val)
						
						traj_length = random.randint(min_traj_length,max_traj_length)
						traj = []
						x = x_orig
						y = y_orig
						
						# Using NASTIC ROI to define selection area
						if Load_ROI == True:
							ct = 0
							try_ct = 1
							while ct < traj_length:
								if try_ct == 1000:
									traj = []
									ct = 0
									x_orig = x_seed + 0.5*(random.uniform(-radius,radius))
									y_orig = y_seed + 0.5*(random.uniform(-radius,radius))
									x = x_orig 
									y = y_orig 
									try_ct = 1
								
								# Orbit
								if orbit:
									# Random walk constrained around spawn point
									prevx = x 
									prevy = y 
									angle = random.uniform(0,360) # random angle for trajectory step
									distance = random.uniform(-steplength,steplength) # random steplength for trajectory step
									x = x_orig +math.sin(angle)*distance
									y = y_orig + math.cos(angle)*distance
									if p.contains_point([x,y]):	
										t += frame_time
										traj.append([x,y,t])
										ct += 1
										try_ct = 1
									else:
										try_ct += 1
										x = prevx 
										y = prevy 
								
								# No orbit
								else:
									# Random walk unconstrained, can wander from spawn point
									prevx = x
									prevy = y
									angle = random.uniform(0,360) # random angle for trajectory step
									distance = random.uniform(-steplength,steplength) # random steplength for trajectory step
									x = x +math.sin(angle)*distance
									y = y + math.cos(angle)*distance	
									if p.contains_point([x,y]):	
										t += frame_time
										t = round(t,frame_time_round_val)
										traj.append([x,y,t])
										ct += 1
										try_ct = 1
									else:
										try_ct += 1
										x = prevx
										y = prevy
										
							trajectories.append(traj)
							clusttrajcounter +=1				
							clusterdict[clustercounter]["trajectories"].append(traj)
								
						# Using x_size and y_size to define selection area
						elif Load_ROI == False:
							ct = 0
							try_ct = 1
							while ct < traj_length:
								if try_ct == 1000:
									traj = []
									x_orig = x_seed + 0.5*(random.uniform(-radius,radius))
									y_orig = y_seed + 0.5*(random.uniform(-radius,radius))
									x = x_orig 
									y = y_orig 
									ct = 0
									try_ct = 1
								
								# Orbit
								if orbit:
									# Random walk constrained around spawn point
									angle = random.uniform(0,360) # random angle for trajectory step
									distance = random.uniform(-steplength,steplength) # random steplength for trajectory step 
									x = x_orig +math.sin(angle)*distance
									if x > x_size:
										x = x_size
									if x<0:
										x = 0
									y = y_orig + math.cos(angle)*distance
									if y>y_size:
										y=y_size
									if y<0:
										y=0		
									if x < x_size and x > 0 and y < y_size and y > 0:
										t += frame_time
										t = round(t,frame_time_round_val)
										traj.append([x,y,t])
										ct += 1
										try_ct = 1
									else:
										try_ct += 1
								
								# No orbit
								else:
									# Random walk unconstrained, can wander from spawn point
									prevx = x
									prevy = y
									angle = random.uniform(0,360) # random angle for trajectory step
									distance = random.uniform(-steplength,steplength) # random steplength for trajectory step
									x = x +math.sin(angle)*distance
									if x > x_size:
										x = x_size
									if x<0:
										x = 0
									y = y + math.cos(angle)*distance	
									if y>y_size:
										y=y_size
									if y<0:
										y=0		
									if x < x_size and x > 0 and y < y_size and y > 0:
										t += frame_time
										t = round(t,frame_time_round_val)
										traj.append([x,y,t])
										ct += 1
										try_ct = 1
									else:
										try_ct += 1
										x = prevx
										y = prevy
										
							trajectories.append(traj)
							clusttrajcounter +=1				
							clusterdict[clustercounter]["trajectories"].append(traj)
			
		# Noise		
		print ("Generating unclustered trajectory seeds...")
		
		# Using NASTIC ROI to define selection area
		if Load_ROI == True:
			noiseseeds = []
			ct = 0
			while ct < noise:
				x = random.uniform(xmin,xmax) # random x
				y = random.uniform(ymin,ymax) # random y
				t = round(random.random()*acquisition_time,frame_time_round_val) # random t
				
				# test whether t can be divided by frame time -> adjust value if not
				int_t = int(round(t*10**frame_time_round_val,0))
				int_frame_time = int(round(frame_time*10**frame_time_round_val,0))
				while int_t %int_frame_time !=0:
					int_t += 1
				t = round(int_t*10**-frame_time_round_val,frame_time_round_val)
				
				if p.contains_point([x,y]):
					noiseseeds.append([x,y,t])
					ct +=1	
			print ("Generating {} unclustered trajectories with higher mobility ({}x number of cluster seeds)...".format(noise, noise_factor))
			for seed in noiseseeds:
				x,y,t = seed[0],seed[1],seed[2] # x, y and t for this cluster
				traj_length = random.randint(min_traj_length,max_traj_length) # steps for this trajectory
				traj = []
				ct = 0
				try_ct = 1
				point_ct = 0
				while ct < traj_length:
					if try_ct == 1000:
						traj = []
						ct = 0
						x,y,t = seed[0],seed[1],seed[2]
						try_ct = 1
						point_ct = 0
					prevx = x 
					prevy = y 
					angle = random.uniform(0,360) # random angle for trajectory step
					distance = unconst*(random.uniform(-steplength,steplength)) # random steplength for trajectory step
					x = x +math.sin(angle)*distance
					y = y + math.cos(angle)*distance	
					if p.contains_point([x,y]):
						if ct > 0:	
							trajx_before = traj[ct-1][0]
							trajy_before = traj[ct-1][1]
							midpoint_list = obtain_midpoints(trajx_before,trajy_before,x,y)
							midpointlistct = 0
							for x_midpoint,y_midpoint in midpoint_list:
								midpointlistct += 1
								if p.contains_point([x_midpoint,y_midpoint]):
									point_ct +=1
							if point_ct == 6:
								t += frame_time
								t = round(t, frame_time_round_val)
								traj.append([x,y,t])
								ct += 1
								try_ct = 1
								point_ct = 0
							else:
								x = prevx
								y = prevy
								point_ct = 0
								try_ct +=1
						else:
							t = seed[2]
							traj.append([x,y,t])
							ct += 1
					else:
						try_ct+=1
						x = prevx 
						y = prevy 
						
				trajectories.append(traj)
		
		# Using x_size and y_size to define selection area
		elif Load_ROI == False:
			noiseseeds = []
			ct = 0
			while ct < noise:
				x = random.random()*x_size # random x
				y = random.random()*y_size # random y
				t = round(random.random()*acquisition_time,frame_time_round_val) # random t
				
				# test whether t can be divided by frame time -> adjust value if not
				int_t = int(round(t*10**frame_time_round_val,0))
				int_frame_time = int(round(frame_time*10**frame_time_round_val,0))
				while int_t %int_frame_time !=0:
					int_t += 1
				t = round(int_t*10**-frame_time_round_val,frame_time_round_val)
				
				noiseseeds.append([x,y,t])
				ct += 1
			
			print ("Generating {} unclustered trajectories with higher mobility ({}x number of cluster seeds)...".format(noise, noise_factor))
			for seed in noiseseeds:
				x,y,t = seed[0],seed[1],seed[2] # x, y and t for this cluster
				traj_length = random.randint(min_traj_length,max_traj_length) # steps for this trajectory
				traj = []
				ct = 0
				try_ct = 1
				while ct < traj_length:
					if try_ct == 1000:
						traj = []
						x,y,t = seed[0],seed[1],seed[2]
						ct = 0
						try_ct = 1
					# Random walk unconstrained, can wander from spawn point
					prevx = x
					prevy = y
					angle = random.uniform(0,360) # random angle for trajectory step
					distance = unconst*(random.uniform(-steplength,steplength)) # random steplength for trajectory step
					x = x +math.sin(angle)*distance
					if x > x_size:
						x = x_size
					if x<0:
						x = 0
					y = y + math.cos(angle)*distance	
					if y>y_size:
						y=y_size
					if y<0:
						y=0		
					if x < x_size and x > 0 and y < y_size and y > 0:
						t += frame_time	
						t = round(t,frame_time_round_val)
						traj.append([x,y,t])
						ct += 1
						try_ct = 1
					else:
						try_ct +=1
						x = prevx
						y = prevy
						
				trajectories.append(traj)		

		# Metrics
		if Load_ROI == False:
			print("\nGenerating metrics")
		elif Load_ROI == True:
			if len(roidict) > 1:
				print("\nGenerating metrics (ROI #{})".format(roi))
			else:
				print("\nGenerating metrics")
		print("------------------------------------------------------------")
		traj_nums = []
		radii= []
		for num in clusterdict:
			cluster_trajectories = clusterdict[num]["trajectories"]
			clusterdict[num]["traj_num"]=len(cluster_trajectories) # number of trajectories in each cluster
			clusterpoints = [point[:2]  for traj in cluster_trajectories for point in traj] # all x,y points for trajectories in cluster 
			ext_x,ext_y,ext_area,int_x,int_y,int_area = double_hull(clusterpoints) # internal and external convex hull of cluster points 
			clusterdict[num]["area"] = int_area # internal hull area as cluster area (um2)
			clusterdict[num]["radius"] = math.sqrt(int_area/math.pi) # radius of cluster internal hull (um)
			traj_nums.append(clusterdict[num]["traj_num"])
			radii.append(clusterdict[num]["radius"])
		print ("Total traj:",clusttrajcounter + noise)
		print ("Clustered traj:",clusttrajcounter)
		print ("Total clusters:", clustercounter)
		print ("Avg traj per cluster:", np.average(traj_nums))
		print ("Avg cluster radius:", np.average(radii))
		if Load_ROI == True:
			trajectory_list.append(trajectories)
			clusttrajcounter_list.append(clusttrajcounter)
			noise_list.append(noise)
			clustercounter_list.append(clustercounter)
			traj_nums_list.append(traj_nums)
			seed_num_list.append(seed_num)
			radii_list.append(radii)
		return()
		
	# Output
	def output(traj_num_ct, stamp,Load_ROI):
		print("\nWriting files")
		print("------------------------------------------------------------")
		print ("Writing trxyt...")
		with open("synthetic_data_output_{}/synthetic_data_{}_{}.trxyt".format(stamp, stamp,traj_num_ct+1),"a") as outfile: 
			
			if Load_ROI == False:
				for tr,traj in enumerate(trajectories,start=1):
					for seg in traj:
						x,y,t = seg
						outline = "{} {} {} {}\n".format(tr,x,y,round(t,frame_time_round_val))
						outfile.write(outline)
			elif Load_ROI == True:
				if len(trajectory_list) > 1:
					trajectory_temp_list = []
					for tr, trajectory in enumerate(trajectory_list):
						for traj in trajectory:
							trajectory_temp_list.append(traj)
					for tr,traj in enumerate(trajectory_temp_list,start=1):
						for seg in traj:
							x,y,t = seg
							outline = "{} {} {} {}\n".format(tr,x,y,round(t,frame_time_round_val))
							outfile.write(outline)
				else:
					for tr,traj in enumerate(trajectories,start=1):
						for seg in traj:
							x,y,t = seg
							outline = "{} {} {} {}\n".format(tr,x,y,round(t,frame_time_round_val))
							outfile.write(outline)
		print ("Writing metrics...")
		with open("synthetic_data_output_{}/synthetic_data_{}_{}_metrics.tsv".format(stamp,stamp,traj_num_ct+1),"a") as outfile: 
			if Load_ROI == False:
				outfile.write("PARAMETERS:\n=================\n")
			elif Load_ROI == True:
				outfile.write("PARAMETERS:\n==================================\n")
			outfile.write("ACQUISITION TIME (s): {}\n".format(acquisition_time))	
			outfile.write("FRAME TIME (s): {}\n".format(frame_time))
			if Load_ROI == True:
				outfile.write("ROI FILE: {}\n".format(roi_file))	
				outfile.write("ROI AREA: {}\n".format(selarea))	
			if Load_ROI == False:
				outfile.write("X SIZE (um): {}\n".format(x_size ))	
				outfile.write("Y SIZE (um): {}\n".format(y_size))
			outfile.write("SEED DENSITY (per um2): {}\n".format(seed_density))
			outfile.write("SEED RADIUS (um): {}\n".format(radius))	
			outfile.write("MIN TRAJ AROUND SEED: {}\n".format(min_traj_num))	
			outfile.write("MAX TRAJ AROUND SEED: {}\n".format(max_traj_num))	
			outfile.write("MIN TRAJ STEPS: {}\n".format(min_traj_length))	
			outfile.write("MAX TRAJ STEPS: {}\n".format(max_traj_length))		
			outfile.write("MAX STEPLENGTH (um): {}\n".format(steplength))
			outfile.write("CLUSTER TRAJ ORBIT: {}\n".format(orbit))	
			outfile.write("NOISE FACTOR: {}\n".format(noise_factor))		
			outfile.write("UNCLUST STEPLENGTH MULTIPLIER: {}\n".format(unconst))
			outfile.write("HOTSPOT PROBABILITY: {}\n".format(hotspotprobability))
			outfile.write("MAX CLUSTERS PER HOTSPOT: {}\n".format(hotspotmax))	
			if Load_ROI == False:
				outfile.write("\nGENERATED METRICS:\n=================\n")
				outfile.write("TOTAL TRAJECTORIES: {}\n".format(clusttrajcounter + noise))
				outfile.write("CLUSTERED TRAJECTORIES: {}\n".format(clusttrajcounter))
				outfile.write("UNCLUSTERED TRAJECTORIES: {}\n".format(noise))	
				outfile.write("TOTAL CLUSTERS: {}\n".format(clustercounter))
				outfile.write("SINGLETON CLUSTERS: {}\n".format(seed_num))
				outfile.write("AVERAGE TRAJECTORIES PER CLUSTER: {} +/- {}\n".format(np.average(traj_nums),np.std(traj_nums)/math.sqrt(len(traj_nums))))	
				outfile.write("AVERAGE CLUSTER RADIUS: {} +/- {}\n".format(np.average(radii),np.std(radii)/math.sqrt(len(radii))))
			if Load_ROI == True:	
				for roi,selarea_roi,clusttrajcounter_roi,noise_roi,clustercounter_roi,seed_num_roi,traj_nums_roi,radii_roi in list(zip(roidict,selarea_list,clusttrajcounter_list,noise_list,clustercounter_list,seed_num_list,traj_nums_list,radii_list)):
					outfile.write("\nGENERATED METRICS (ROI #{}):\n==================================\n".format(roi))
					outfile.write("ROI AREA: {}\n".format(selarea_roi))	
					outfile.write("TOTAL TRAJECTORIES: {}\n".format(clusttrajcounter_roi + noise_roi))
					outfile.write("CLUSTERED TRAJECTORIES: {}\n".format(clusttrajcounter_roi))
					outfile.write("UNCLUSTERED TRAJECTORIES: {}\n".format(noise_roi))	
					outfile.write("TOTAL CLUSTERS: {}\n".format(clustercounter_roi))
					outfile.write("SINGLETON CLUSTERS: {}\n".format(seed_num_roi))
					outfile.write("AVERAGE TRAJECTORIES PER CLUSTER: {} +/- {}\n".format(np.average(traj_nums_roi),np.std(traj_nums_roi)/math.sqrt(len(traj_nums_roi))))	
					outfile.write("AVERAGE CLUSTER RADIUS: {} +/- {}\n".format(np.average(radii_roi),np.std(radii_roi)/math.sqrt(len(radii_roi))))
				if len(roidict) > 1:
					outfile.write("\nGENERATED METRICS (COMBINED ROIS):\n==================================\n")
					outfile.write("ROI AREA: {}\n".format(sum(selarea_list)))
					outfile.write("TOTAL TRAJECTORIES: {}\n".format(sum(clusttrajcounter_list) + sum(noise_list)))
					outfile.write("CLUSTERED TRAJECTORIES: {}\n".format(sum(clusttrajcounter_list)))
					outfile.write("UNCLUSTERED TRAJECTORIES: {}\n".format(sum(noise_list)))	
					outfile.write("TOTAL CLUSTERS: {}\n".format(sum(clustercounter_list)))
					outfile.write("SINGLETON CLUSTERS: {}\n".format(sum(seed_num_list)))
					new_traj_nums_list = []
					for roi in traj_nums_list:
						for traj in roi:
							new_traj_nums_list.append(traj)
					new_radii_list = []
					for radii_roi in radii_list:
						for rad in radii_roi:
							new_radii_list.append(rad)
				

					outfile.write("AVERAGE TRAJECTORIES PER CLUSTER: {} +/- {}\n".format(np.average(new_traj_nums_list),np.std(new_traj_nums_list)/math.sqrt(len(new_traj_nums_list))))	
					outfile.write("AVERAGE CLUSTER RADIUS: {} +/- {}\n".format(np.average(new_radii_list),np.std(new_radii_list)/math.sqrt(len(new_radii_list))))
		return ()
	
	def plot_traj(traj_num_ct):
		global selverts, roidict, x_size, y_size
		print("Plotting trajectories...")
		fig = plt.figure(traj_num_ct+1,figsize=(6,6))
		
		#Plot parameters
		ax = plt.subplot(111)
		detection_alpha = 0.05
		line_alpha = 0.25	
		line_width = 1.5	
		cmap = "inferno"
		detpoints = []
		tr = []
		
		#Draw trajectories on plot
		if Load_ROI == True:
			if len(trajectory_list) > 1:
				trajectory_temp_list = []
				for trajectory in trajectory_list:
					for traj in trajectory:
						trajectory_temp_list.append(traj)
	
				for num,traj in enumerate (trajectory_temp_list,start = 1):
					[detpoints.append(i) for i in traj]
					x,y,t = zip(*traj)
					tr = matplotlib.lines.Line2D(x,y,c="w",alpha=line_alpha,linewidth=line_width)
					ax.add_artist(tr) 	
			else:
				for num,traj in enumerate (trajectories, start = 1):
					[detpoints.append(i) for i in traj]
					x,y,t = zip(*traj)
					tr = matplotlib.lines.Line2D(x,y,c="w",alpha=line_alpha,linewidth=line_width)
					ax.add_artist(tr) 	
		else:
			for num,traj in enumerate (trajectories, start = 1):
				[detpoints.append(i) for i in traj]
				x,y,t = zip(*traj)
				tr = matplotlib.lines.Line2D(x,y,c="w",alpha=line_alpha,linewidth=line_width)
				ax.add_artist(tr) 		
		x_plot,y_plot,t_plot = zip(*detpoints)
		
		#Draw ROI on plot
		print("Plotting selection area...")
		if Load_ROI == True:
			for roi in roidict:			
				selverts =roidict[roi]
				vx, vy = list(zip(*selverts))
				roi = ax.plot(vx,vy,linewidth=2,c="green",alpha=1)
		
		elif Load_ROI == False:
			x = (0, 0, x_size, x_size,0)
			y = (0, y_size, y_size, 0, 0)
			roi = ax.plot(x,y,linewidth=2,c="green",alpha=1)
			
		ax.scatter(x_plot,y_plot,c="w",s=3,linewidth=0,alpha=detection_alpha)
		ax.set_facecolor("k")	
		ax.set_xlabel("X")
		ax.set_ylabel("Y")	
		xlims = plt.xlim()
		ylims = plt.ylim()
		ax.imshow([[0,1], [0,1]], extent = (xlims[0],xlims[1],ylims[0],ylims[1]), cmap = cmap, interpolation = 'bicubic',alpha=0)
		plt.tight_layout()
		plt.show(block=False)
		
		# Pickle this raw image
		buf = io.BytesIO()
		pickle.dump(fig, buf)
		buf.seek(0)
		
		if save_all_plots == True:
			savefile = "synthetic_data_output_{}/synthetic_data_{}_{}.png".format(stamp, stamp,traj_num_ct+1)
			fig.savefig(savefile,dpi=300)
		
	# GET INITIAL VALUES FOR GUI
	cwd = os.path.dirname(os.path.abspath(__file__))
	os.chdir(cwd)
	initialdir = cwd
	if os.path.isfile("synthetic_data_generator_gui.defaults"):
		load_defaults()
	else:
		reset_defaults()
		save_defaults()
	
	# GUI LAYOUT
	appFont = ("Any 12")
	sg.set_options(font=appFont)
	sg.theme('DARKGREY11')
	
	# Menu
	menu_def = [
		['&File', ['&Load settings', '&Save settings','&Default settings','&Exit']],
		['&Info', ['&About', '&Help','&Licence','&Updates']],
		]
		
	syn_acq_layout = [
		[sg.T("    Acquisition time (s):", tooltip = "Pretend length of time taken to 'acquire' all frames\nUnits = seconds"), sg.In(acquisition_time, size = (7,1), key = '-ACQ_TIME-'),sg.Push(),sg.T("Frame time (s):", tooltip = "Pretend length of time taken to 'acquire' a single frame\nUnits = seconds"), sg.In(frame_time, size = (7,1), key = '-FRAME_TIME-')],
		]
		
	syn_ROI_layout = [
		[sg.Radio("Option 1: define using pretend x,y frame size", key = "-USE_XY-", default = True, enable_events = True, group_id = 1)],
		[sg.T("         x-axis size (um):", tooltip = "Determine selection area using a pretend frame size (x-axis length)\nUnits = microns\n(instead of loading a previously saved NASTIC ROI file)", key = "-X_SIZE_TEXT-", text_color = "#cccdcf"), sg.In(x_size, size = (7,1), key = '-X_SIZE-', text_color = "#cccdcf",disabled_readonly_background_color = "#313641", disabled = False), sg.Push(), sg.T("y-axis size (um):", tooltip = "Determine selection area using a pretend frame size (y-axis length)\nUnits = microns\n(instead of loading a previously saved NASTIC ROI file)", key = "-Y_SIZE_TEXT-", text_color = "#cccdcf"), sg.In(y_size, size = (7,1), key = '-Y_SIZE-',text_color = "#cccdcf",disabled_readonly_background_color = "#313641", disabled = False)],
		[sg.Radio("Option 2: define using presaved NASTIC ROI", key = "-USE_ROI-", enable_events = True, group_id = 1)],
		[sg.FileBrowse("Browse File", tooltip = "Determine selection area using a previously generated NASTIC roi_coordinates.tsv file\nUnits = microns\n(instead of using x-axis size and y-axis size to generate a pretend frame size)", file_types = (("NASTIC ROI file", "roi_coordinates*.tsv"),),key = '-BROWSE_ROI-', target = '-SELECTED_ROI-', disabled = True), sg.In("Load previously defined NASTIC ROI", key = '-SELECTED_ROI-', size = (45,1), enable_events = True, text_color = "#cccdcf", disabled_readonly_background_color="#313641", disabled_readonly_text_color = "grey", disabled = True)],
		]
		
	syn_seed_layout = [
		[sg.T("             Seed density:", tooltip = "Number of spawn points (seeds) per um2 of the selection area \nfrom which a single cluster will occur"), sg.In(seed_density, size = (7,1), key = '-SEED_DENSITY-'), sg.Push(), sg.T("Seed radius (um):", tooltip = "Radius around each seed to make trajectories\nUnits = microns"), sg.In(radius, size = (7,1), key = '-RADIUS-')],
		[sg.T("                  Min traj #:", tooltip = "Minimum number of trajectories around each seed"), sg.In(min_traj_num, size = (7,1), key = '-MIN_TRAJ_NUM-'),sg.Push(),sg.T("          Max traj #:",tooltip = "Maximum number of trajectories around each seed"), sg.In(max_traj_num, size = (7,1), key = '-MAX_TRAJ_NUM-')],
		[sg.T("           Min traj length:", tooltip = "Minimum number of trajectory steps"), sg.In(min_traj_length, size = (7,1), key = '-MIN_TRAJ_LEN-'), sg.Push(), sg.T("Max traj length:", tooltip = "Maximum number of trajectory steps"), sg.In(max_traj_length, size = (7,1), key = '-MAX_TRAJ_LEN-')],
		[sg.T("       Step length (um):", tooltip = "Maximum step length within a trajectory\nUnits = microns"), sg.In(steplength, size = (7,1), key = '-STEP_LEN-'), sg.Push(),sg.T("       Clustered traj orbit seed:", tooltip = "Clustered trajectories orbit their spawn point rather than random walking"), sg.Checkbox("", default = True, key = '-ORBIT-', enable_events = True)],
		]
	
	syn_unclustered_traj_layout = [
		[sg.T("               Noise factor:", tooltip = "Noise factor multiplier used to calculate the number of unclustered trajectories per seed"), sg.In(noise_factor, size = (7,1), key = '-NOISE_FACTOR-'), sg.Push(),sg.T("Step length multiplier:", tooltip = "Step length multiplier used to calculate unclustered trajectory step length"), sg.In(unconst, size = (7,1), key = '-STEP_LEN_UNCLUST-')],
		]
		
	syn_hotspot_layout = [
		[sg.T("             Hotspot prob:", tooltip = "Chance of a given seed point generating multiple spatially overlapping but temporally distinct clusters"), sg.In(hotspotprobability, size = (7,1), key = '-HOTSPOT_PROB-'), sg.Push(),sg.T("   Max hotspot clust #:", tooltip = "Maximum number of temporal clusters at a given hotspot"), sg.In(hotspotmax, size = (7,1), key = '-MAX_HOTSPOT_TRAJ-')],
		]
	
	syn_output_layout = [
		[sg.Checkbox("Display plot for every TRXYT generated", key = "-DISPLAY_ALL_PLOTS-", default = False),sg.Push(),sg.Checkbox("Save displayed plots", key = "-SAVE_ALL_PLOTS-", default = True)],
		]
	
	layout = [
		[sg.Menu(menu_def)],
		[sg.T("SYNTHETIC",font=("Any",20))],
		[sg.T("Generate synthetic TRXYT data using the below parameters:", font = ("Any 12 italic"))],
		[sg.Frame("ACQUISITION", syn_acq_layout, expand_x = True, pad = ((0,0), (15,15)))],
		[sg.Frame("SELECTION AREA", syn_ROI_layout, expand_x = True, pad = ((0,0),(0,15)))],
		[sg.Frame("CLUSTERED TRAJECTORIES", syn_seed_layout, expand_x = True, pad = ((0,0), (0,15)))],
		[sg.Frame("UNCLUSTERED TRAJECTORIES",syn_unclustered_traj_layout, expand_x = True, pad = ((0,0), (0,15)))],
		[sg.Frame("HOTSPOTS", syn_hotspot_layout, expand_x = True, pad = ((0,0), (0,15)))],
		[sg.Frame("TRAJECTORY PLOTS", syn_output_layout, expand_x = True, pad = ((0,0), (0,15)))],
		[sg.Push(),sg.T("# of TRXYT files to generate:"), sg.In(trxyt_num, key = '-TRXYT_NUM-', size = (7,1)), sg.Push(),sg.B("GENERATE TRXYT", key = '-GENERATE-'), sg.Push()],
	]

	window = sg.Window('SYNTHETIC Data Generator v{}'.format(last_changed),layout)
	popup.close()

	# MAIN LOOP
	while True:
		# Read events and values
		event, values = window.read(timeout = 5000)
		
		# Exit	
		if event == sg.WIN_CLOSED or event == 'Exit':  
			break
		
		# Values
		acquisition_time = values['-ACQ_TIME-'] # pretend length of acquisition
		frame_time = values['-FRAME_TIME-'] # sec 
		use_xy = values['-USE_XY-'] # use x-axis size and y-axis size to determine selection area
		use_ROI = values['-USE_ROI-'] # use selected NASTIC ROI to determine selection area
		x_size = values['-X_SIZE-'] # pretend microns
		y_size = values['-Y_SIZE-'] # pretend microns
		roi_file = values['-SELECTED_ROI-']
		seed_density = values['-SEED_DENSITY-'] # how many cluster seeds per um2 of selection area
		min_traj_num = values['-MIN_TRAJ_NUM-'] # min number of trajectories around each seed (default 4)
		max_traj_num = values['-MAX_TRAJ_NUM-'] # max number of trajectories around each seed (default 16)
		min_traj_length = values['-MIN_TRAJ_LEN-'] # min number of trajectory steps (default 5)
		max_traj_length = values['-MAX_TRAJ_LEN-'] # max number of trajectory steps (default 30)
		radius = values['-RADIUS-'] # radius around each seed to make trajectories (um)
		steplength = values['-STEP_LEN-'] # maximum step length within trajectory (um)
		noise_factor = values['-NOISE_FACTOR-'] # number of unclustered trajectories 
		unconst = values['-STEP_LEN_UNCLUST-'] # steplength multiplier of unclustered trajectories
		hotspotprobability = values['-HOTSPOT_PROB-'] # chance of a given seed point generating multiple spatially overlapping but temporally distinct clusters
		hotspotmax = values['-MAX_HOTSPOT_TRAJ-'] # maximum number of temporal clusters at a given hotspot
		orbit = values['-ORBIT-'] # clustered trajectories orbit their spawn point rather than random walking
		display_all_plots = values['-DISPLAY_ALL_PLOTS-']
		save_all_plots = values['-SAVE_ALL_PLOTS-']
		trxyt_num = values['-TRXYT_NUM-'] # number of trxyt files to generate
		
	
		# Check variables
		check_variables()
		
		# Reset to hard coded default values
		if event == 'Default settings':
			reset_defaults()
			update_buttons()
				
		# Save settings
		if event == 'Save settings':
			save_defaults()
				
		# Load settings
		if event == 'Load settings':
			load_defaults()
			update_buttons()
						
		# About
		if event == 'About':
			splash = create_splash()	
			splash.close()
			
		# Help	
		if event == 'Help':
			sg.Popup(
				"Help",
				"This program generates synthetic .trxyt files based on parameters defined by the user, for use in nanoscale spatiotemporal indexing clustering (NASTIC and segNASTIC) or 3D DBSCAN (BOOSH).",
				"ACQUSITION - parameters defining the time dimensions of the \n     pretend acquisition data.",
				"SELECTION AREA - parameters defining the spatial dimensions \n     of the pretend acquistion data.\n     Option 1: use x-axis size (um) and y-axis size (um)\n     Option 2: use previously saved NASTIC ROI file \n     (roi_coordinates.tsv).",
				"CLUSTERED TRAJECTORIES - parameters defining the behaviour \n     of clustered trajectories. \n     Seed = point at which a single cluster will form. \n     Step length = step size within a clustered trajectory.",
				"UNCLUSTERED TRAJECTORIES - parameters defining the behaviour \n     of unclustered trajectories. \n     Noise factor = value multiplied by the seed number to \n     get the number of unclustered trajectories per seed\n     Step length multiplier = value multiplied by the \n     clustered trajectory step length to obtain the \n     step size within unclustered trajectories.",
				"HOTSPOTS - parameters defining the behaviour of hotspots. \n     Hotspot = point at which multiple spatially overlapping \n     but temporally distinct clusters form.",
				"GENERATE TRXYT - generates synthetic .trxyt files based on \n     the selected parameters, and a corresponding \n     metrics.tsv file containing the parameters that were \n     selected, and the metrics which they generated. Both \n     file types are saved in the same directory as the \n     synthetic_data_generator_gui.py python script, in a \n     folder that is generated with the naming format \n     'synthetic_data_output_YYYYMMDD-HHMMSS'.",
				"Tristan Wallis, Alex McCann {}".format(last_changed),
				no_titlebar = True,
				grab_anywhere = True,
				keep_on_top = True,
				)	
		
		# Check for updates
		if event == 'Updates':
			webbrowser.open("https://github.com/tristanwallis/smlm_clustering/releases",new=2)
			
		# Licence	
		if event == 'Licence':
			sg.Popup(
				"Licence",
				"Creative Commons CC BY 4.0",
				"https://creativecommons.org/licenses/by/4.0/legalcode", 
				no_titlebar = True,
				grab_anywhere = True,
				keep_on_top = True,
				)				
				
		if event == '-USE_XY-' or '-USE_ROI-':
			if use_xy == True:
				window.Element("-BROWSE_ROI-").update(disabled = True)
				window.Element("-SELECTED_ROI-").update("Load previously defined NASTIC ROI", disabled = True, text_color = "grey")	
				window.Element("-X_SIZE-").update(disabled = False, text_color = "#cccdcf")
				window.Element("-Y_SIZE-").update(disabled = False, text_color = "#cccdcf")
				window.Element("-X_SIZE_TEXT-").update(text_color = "#cccdcf")
				window.Element("-Y_SIZE_TEXT-").update(text_color = "#cccdcf")
				Load_ROI = False
				
			elif use_ROI == True:
				window.Element("-BROWSE_ROI-").update(disabled = False)
				window.Element("-SELECTED_ROI-").update(disabled = False, text_color = "#cccdcf")
				window.Element("-X_SIZE-").update(disabled = True, text_color = "grey", background_color = "#313641")
				window.Element("-Y_SIZE-").update(disabled = True, text_color = "grey", background_color = "#313641")
				window.Element("-X_SIZE_TEXT-").update(text_color = "grey")
				window.Element("-Y_SIZE_TEXT-").update(text_color = "grey")
			
		if event == '-GENERATE-':
			time.sleep(0.5)
			traj_num_ct = 0
			stamp = '{:%Y%m%d-%H%M%S}'.format(datetime.datetime.now()) # datestamp
			try:
				os.mkdir("synthetic_data_output_{}".format(stamp))
			except:
				sg.Popup("Alert", "Error generating output folder (folder name already exists). Please try again")
			# Using NASTIC ROI to define selection area
			if use_ROI == True:
				if roi_file != "Load previously defined NASTIC ROI":
					read_roi()
					Load_ROI = True
					fig = plt.subplot(111)
					plt.close('all') # clear last plot if present
					
					while traj_num_ct < trxyt_num:
						if trxyt_num == 1:
							print("\n\nGenerating trxyt file")
						else:
							print("\n\nGenerating trxyt file # {}".format(traj_num_ct+1))
						print("============================================================")
						for roi,p,selarea in zip(roidict,p_list,selarea_list):
							generate_trxyt(Load_ROI)
						if len(roidict) > 1:
							new_traj_nums_list = []
							for roi in traj_nums_list:
								for traj in roi:
									new_traj_nums_list.append(traj)
							new_radii_list = []
							for radii_roi in radii_list:
								for rad in radii_roi:
									new_radii_list.append(rad)
							print("\nCombined ROI metrics")
							print("------------------------------------------------------------")
							print("Selection area: {}".format(sum(selarea_list)))
							print("Total traj: {}".format(sum(clusttrajcounter_list) + sum(noise_list)))
							print("Clustered traj: {}".format(sum(clusttrajcounter_list)))
							print("Unclustered traj: {}".format(sum(noise_list)))
							print("Total clusters: {}".format(sum(clustercounter_list)))
							print("Avg traj per cluster: {} +/- {}".format(np.average(new_traj_nums_list),np.std(new_traj_nums_list)/math.sqrt(len(new_traj_nums_list))))	
							print("Avg cluster radius: {} +/- {}".format(np.average(new_radii_list),np.std(new_radii_list)/math.sqrt(len(new_radii_list))))
						output(traj_num_ct, stamp,Load_ROI)
						if display_all_plots == True:
							plot_traj(traj_num_ct)
						traj_num_ct+=1
					if display_all_plots == False:
						plot_traj(0)
						
					print("\n\nDONE!\n\n")
					if save_all_plots == False:
						print("\nTRXYT and metrics files saved to: \n{}".format(cwd) + "\\synthetic_data_output_{}".format(stamp) + "\n")
					elif save_all_plots == True:
						print("\nTRXYT, metrics and plots saved to: \n{}".format(cwd) + "\\synthetic_data_output_{}".format(stamp) + "\n")
					print("\n============================================================\n")
			# Using x_size and y_size to define selection area
			else:
				Load_ROI = False
				fig = plt.subplot(111)
				plt.close('all') # clear last plot if present
				while traj_num_ct < trxyt_num:
					print("\nGenerating trxyt file # {}\n============================================================".format(traj_num_ct+1))
					generate_trxyt(Load_ROI)
					output(traj_num_ct, stamp,Load_ROI)
					if display_all_plots == True:
						plot_traj(traj_num_ct)
					traj_num_ct+=1
				if display_all_plots == False:
					plot_traj(0)
					
				print("\nDONE!")
				if save_all_plots == False:
					print("\nTRXYT and metrics files saved to: \n{}".format(cwd) + "\\synthetic_data_output_{}".format(stamp) + "\n")
				elif save_all_plots == True:
					print("\nTRXYT, metrics and plots saved to: \n{}".format(cwd) + "\\synthetic_data_output_{}".format(stamp) + "\n")
				print("============================================================\n\n")
		
		# Update buttons	
		if event: 
			update_buttons()
			
	print ("\nExiting...")
	window.close()	
	quit()